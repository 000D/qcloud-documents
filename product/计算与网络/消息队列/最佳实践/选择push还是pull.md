
腾讯云的 CMQ 支持 Pull、Push 两种方式，而这两种方式的适用场景是什么呢？我们简要分析下push和 pull模型，在不同场景下各自存在的利弊。


###Push和Pull的区别

所谓Push模型，即是当Producer发出的消息到达后，服务端马上将这条消息投递给Consumer；而Pull则是服务端收到这条消息后什么也不做，只是等着Consumer主动到自己这里来读，即Consumer这里有一个“拉取”的动作。

---


###**场景1：Producer的速率大于Consumer的速率**

对于Producer速率大于Consumer速率的情况，有两种可能性需要讨论，第一种是Producer本身的效率就要比Consumer高（比如说，Consumer端处理消息的业务逻辑可能很复杂，或者涉及到磁盘、网络等I/O操作）；另一种则是Consumer出现故障，导致短暂时间内无法消费或消费不畅。

Push方式由于无法得知当前Consumer的状态，所以只要有数据产生，便会不断地进行推送，在以上两种情况下时，可能会导致Consumer的负载进一步加重，甚至是崩溃（比如生产者是flume疯狂抓日志，消费者是HDFS+hadoop，处理效率跟不上）。除非Consumer有合适的反馈机制能够让服务端知道自己的状况。

而采取Pull的方式问题就简单了许多，由于Consumer是主动到服务端拉取数据，此时只需要降低自己访问频率就好了。举例：如前端是flume等日志收集业务，不断往CMQ生产消息，CMQ往后端投递，后端业务如数据分析等业务，效率可能低于生产者。


---


###**场景2：强调消息的实时性**

采用Push的方式时，一旦消息达到，服务端即可马上将其推送给服务端，这种方式的实时性显然是非常好的；而采用Pull方式时，为了不给服务端造成压力（尤其是当数据量不足时，不停的轮询显得毫无意义），需要控制好自己轮询的间隔时间，但这必然会给实时性带来一定的影响。


---


###**场景3：Pull的长轮询**

Pull模式有什么问题呢？由于主动权在消费方，消费方无法准确地决定何时去拉取最新的消息。如果一次 pull 取到消息了还可以继续去 pull，如果没有 pull 取到消息则需要等待一段时间再重新 pull。

但等待时间就很难判定了。你可能会说，我可以有xx动态拉取时间调整算法，但问题的本质在于，有没有消息到来这件事情决定权不在消费方。也许1分钟内连续来了1000条消息，然后半个小时没有新消息产生，可能你的算法算出下次最有可能到来的时间点是31分钟之后，或者60分钟之后，结果下条消息10分钟后到了，是不是很让人沮丧？

当然也不是说延迟就没有解决方案了，业界较成熟的做法是从短时间开始（不会对 CMQ broker 有太大负担），然后指数级增长等待。比如开始等5ms，然后10ms，然后20ms，然后40ms……直到有消息到来，然后再回到5ms。即使这样，依然存在延迟问题：假设40ms 到80ms 之间的50ms 消息到来，消息就延迟了30ms，而且对于半个小时来一次的消息，这些开销就是白白浪费的。

在腾讯云的 CMQ 里，有一种优化的做法-**长轮询**，来平衡 pull/push 模型各自的缺点。基本方式是：消费者如果尝试拉取失败，不是直接 return，而是把连接挂在那里 wait，服务端如果有新的消息到来，把连接拉起，返回最新消息。


---


###**场景4：部分或全部Consumer不在线**

在消息系统中，Producer和Consumer是完全解耦的，Producer发送消息时，并不要求Consumer一定要在线，对于Consumer也是同样的道理，这也是消息通信区别于RPC通信的主要特点；但是对于Consumer不在线的情况，却有很多值得讨论的场景；

首先，在Consumer偶然宕机或下线的情况下，Producer的生产是可以不受影响的，当Consumer上线后，可以继续之前的消费，此时消息数据不会丢失；但是如果Consumer长期宕机或是由于机器故障无法再次启动时，就会出现问题，即服务端需不需要为Consumer保留数据，以及保留多久的数据等等；

在采用Push方式时，因为无法预知Consumer的宕机或下线是短暂的还是持久的，如果一直为该Consumer保留自宕机开始的所有历史消息，那么即便其他所有的Consumer都已经消费完成，数据也无法清理掉，随着时间的积累，队列的长度会越来越大，此时无论消息是暂存于内存还是持久化到磁盘上（采用Push模型的系统，一般都是将消息队列维护于内存中，以保证推送的性能和实时性，这一点会在后边详细讨论），都将对CMQ服务端造成巨大压力，甚至可能影响到其他Consumer的正常消费，尤其当消息的生产速率非常快时更是如此；但是如果不保留数据，那么等该Consumer再次起来时，则要面对丢失数据的问题；

折中的方案是：CMQ给数据设定一个超时时间，当Consumer宕机时间超过这个阈值时，则清理数据；但这个时间阈值也并太容易确定；

在采用Pull模型时，情况会有所改善；服务端不再关心Consumer的状态，而是采取“你来了我才服务”的方式，Consumer是否能够及时消费数据，服务端不会做任何保证（也有超时清理时间）。