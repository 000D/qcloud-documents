#CMQ消息去重最佳实践
对于重复消息，最好的方法是消息可重入（消息重复消费对业务无影响）。做不到可重入时，需要在消费端去重。##一、重复消息出现的原因
![](//mc.qcloudimg.com/static/img/821719ad41adc3c8e8de2473e6f3fbf5/image.png)网络异常、服务器宕机等原因都有可能导致消息丢失。CMQ为了做到不丢消息、可靠交付，采用了消息生产、消费确认机制。生产消息确认：生产者向CMQ发送消息后，等待CMQ回复确认；CMQ将消息持久化到磁盘后，向生产者返回确认成功。否则在生产者请求超时、CMQ返回失败等情况下，生产者需要向CMQ重发消息。消费者确认：CMQ向消费者交付消息后，将消息置为不可见；在消息不可见时间内，消费者使用句柄删除消息。如果消息未被删除，且不可见时间超时，消息将重新可见。由于消息确认机制是“至少一次交付（at least once）”，在网络抖动、生产者/消费者异常等情况下，就会出现生产者重复生产、消费者重复消费等情况。##二、去重方案要去重，先要识别重复消息。通常的做法是在生产消息时，业务方在消息体中插入ID，消费时通过该ID来识别重复消息。ID可以是由生产者IP+线程ID+时间戳+时间内递增值组成的唯一值。当只有一个消费者时，可以将消费过的ID缓存（如KV等），然后每次消费时检查ID是否已消费过。ID缓存可以根据消息最大有效时间来淘汰。CMQ提供了队列当前最小未消费消息的时间（min_msg_time），可以使用该时间和业务生产消息最大重试时间来确定缓存淘汰时间。当存在多个消费者时，ID缓存就需要是分布式的。•	根据消息最大有效时间，计算ID过期时间：current_time - max_retention_time - max_retry_time - max_network_time•	根据CMQ最小未消费时间，计算ID过期时间：min_msg_time - max_retry_time - max_network_time说明：
![](//mc.qcloudimg.com/static/img/dbff4055c9fa8a10160ff59a830c016c/image.jpg)
CMQ可配置消息最大有效时间为15天，业务可根据实际情况调整。CMQ队列当前最小未消费消息时间，即上图中最远时间点。该时间之前的消息都已经被删除，之后的消息可能未被删除。##三、举例说明（1）**避免重复提交**：若A为生产者，B为消费者，中间是CMQ。当A已经将10元转账操作完成了，且将消息发送给CMQ，CMQ也成功收到。此时网络闪断或者客户端A宕机导致服务端应答给客户端A失败。A会认为发送失败，从而再次生产消息。这会造成重复提交。解决方法：A在生产消息时，加入time时间戳等信息，生成唯一的ID。当生产者A由于网络问题判断当前发送失败，重试时，ID沿用第一次发送的ID。此时消费者B，可通过ID判断，做去重。（该案例也说明了不能使用CMQ的message id来去重，因为这两条消息有不同的ID，但却有相同的body）（2）**body相同，避免被过滤**：还有一种场景，就是A给B转账10元，一共发起5次，每一次提交的body内容是一样的。如果消费者粗暴用body做去重判断，就会把5次请求，当做1次请求来处理解决方法：A在生产消息时，加入time时间戳等信息。此时哪怕消息body一样，生成的ID都是不同的。这样满足了多次发送同样内容的需求