# 分布式版本编程与使用规范
> **注意：**
> 本文未特定知名的情况下，DCDB 均指代分布式云数据库 DCDB for Percona、MariaDB。

## 1. 概述
DCDB 是部署在腾讯云公有云上的一种兼容 MySQL 协议和语法，支持自动水平拆分的分布式数据库。分布式数据库即业务获取是完整的逻辑库表，后端却将库表均匀的拆分到多个物理分片节点。目前，DCDB 默认部署主从架构且提供了容灾、备份、恢复、监控、迁移等方面的全套解决方案，适用于 TB 或 PB 级的海量数据库场景。
DCDB 采用的水平切分的分布式方案，即根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面，这种切分称为数据的水平切分。

## 2. 使用规范
### 2.1 不兼容概述
以下为暂不支持的内容：
- 跨节点的 join。
- 批量插入如果拆分到两个不同的分片，将不支持。此时仅支持 shardkey 取值一样的情况下的批量操作。
- 视图、存储过程、触发器。
-	自建分区。
-	子查询，having子句。
- MySQL 3.4.0以下的版本、SSL、压缩协议。
关于兼容性详情请参考[兼容性说明](https://www.qcloud.com/doc/product/237/%E5%85%BC%E5%AE%B9%E6%80%A7%E8%AF%B4%E6%98%8E)。

### 2.2 数据库连接
分布式云数据库 DCDB 仍然提供了唯一的 IP，端口供用户访问和使用，示例如下：
>**注意：**
>只有在云服务器 CVM 上才可通过内网地址进行连接，否则需要开通外网地址。

```
mysql -h10.231.136.34 -P3306 -utest12 -ptestpassword
```

### 2.3 建表
建表时必须在最后指定分表键（shardkey），该值为表中的一个字段名字，用于 SQL 的路由选择。
```
mysql> create table test1 ( a int , b int, c char(20) );
ERROR 1005 (07000): Proxy Warning - sql is not legal,tokenizer_gram went wrong

mysql> create table test1 ( a int , b int, c char(20) ) shardkey=a;
Query OK, 0 rows affected (1.56 sec)
```
分表键（shardkey）有如下限制：
1. 如存在主键或者唯一索引，则分表键必须是主键或所有唯一索引的一部分。
2. 如包含多个唯一索引（包括主键），则这些索引必须有交集字段，且此字段必须为分表键 。
3. 分表键字段的类型必须是 int , bigint , smallint / char / varchar。
4. 分表键字段的值不应该有中文，网关不会转换字符集，所以不同字符集路由可能会选择到不同的分区。
5. 无法`update`分表键字段的值。

### 2.4 增删查改
`select`：建议您带上分表键字段，若不带上也可以使用，但此时搜索数据需要全表扫描，然后网关进行结果集聚合，对性能有极大影响。
```
mysql> select * from test1 where a=2;
+------+------+---------+
| a     | b     | c        |
+------+------+---------+
| 2     | 3     | record2 |
| 2     | 4     | record3 |
+------+------+---------+
2 rows in set (0.00 sec)
```

`insert/replace`：字段必须包含分表键，否则会拒绝执行该sql，因为 proxy 无法确认应该插入到哪一个分片。
```
mysql> insert into test1 (b,c) values(4,"record3");
ERROR 1105 (07000): Proxy Warning - sql have no shardkey

mysql> insert into test1 (a,c) values(4,"record3");
Query OK, 1 row affected (0.01 sec)
```

`delete/update`为了安全考虑，我们要求执行该类 sql 的时候必须带有 where 条件，否则将拒绝执行该 sql 命令。
```
mysql> delete from test1;
ERROR 1005 (07000): Proxy Warning - sql is not legal,tokenizer_gram went wrong

mysql> delete from test1 where a=1;
Query OK, 1 row affected (0.01 sec)
```

### 2.5 join
当前 DCDB 只支持单个 shard 内的 join 操作，单个 shard 意味着在一个事务内的所有 sql 必须操作同一个 shard，因此必须指定分表键字段。
```
mysql> create table test1 ( a int , b int, c char(20) ) shardkey=a;
Query OK, 0 rows affected (1.56 sec)

mysql> create table test2 ( a int , d int, e char(20) ) shardkey=a;
Query OK, 0 rows affected (1.46 sec)

mysql> insert into test1 (a,b,c) values(1,2,"record1"),(2,3,"record2");
Query OK, 2 rows affected (0.02 sec)

mysql> insert into test2 (a,d,e) values(1,3,"test2_record1"),(2,3,"test2_record2");
Query OK, 2 rows affected (0.02 sec)

mysql> select * from test1 join test2 on test1.a=test2.a;
ERROR 1105 (07000): Proxy Warning - join shardkey error
mysql> select * from test1 join test2 on test1.a=test2.a where test1.a=1;
+------+------+---------+------+------+---------------+
| a     | b     | c        | a     | d     | e                |
+------+------+---------+------+------+---------------+
| 1     | 2     | record1 | 1    | 3      | test2_record1 |
+------+------+---------+------+------+---------------+
1 row in set (0.00 sec)
```

>**注意：**
>`mysql> select * from test1 join test2 on test1.a=test2.a;`语句在后续版本中会支持，但必须是 inner join 且 inner join 的 where 条件必须是两张表的 shardkey 字段相等。

### 2.6 事务

DCDB 支持分布式事务，为了使用分布式事务功能，在创建完集群之后连接任意一个 proxy 运行如下 sql 进行初始化。
>**注意：**
>该 sql 会创建 xa.gtid_log_t，用户在后续使用中切勿对其进行任何操作。
```
mysql> xa init;
	Query OK, 0 rows affected (0.03 sec)
```

新增 sql 如下：
1. select gtid()
获取当前分布式事务的 gtid (事务的全局唯一性标识)，如果该事务不是分布式事务则返回空。
>**注意：**
>gtid的格式：‘网关id’-‘网关随机值’-‘序列号’-‘时间戳’-‘分区号’，例如 c46535fe-b6-dd-595db6b8-25

2. select gtid_state(“gtid”)
获取 gtid 的状态，可能的结果如下：
 1\. COMMIT，标识该事务已经或者最终会被提交。
 2\. ABORT，标识该事务最终会被回滚。
 3\.  空，由于事务的状态会在一个小时之后清楚，因此有以下两种可能：
	- 一个小时之后查询，标识事务状态已经清除。
	-  一个小时以内查询，标识事务最终会被回滚。
		
3. 运维命令
xa recover：向后端 set 发送 xa recover 命令，并进行汇总。
xa lockwait：显示当前分布式事务的等待关系（可以使用 dot 命令将输出转化为等待关系图）。
xa show：当前网关上正在运行的分布式事务。
		
建议的sql编程方式如下：
```
	(python程序)			
		db = pymysql.connect(host=testHost, port=testPort, user=testUser, password=testPassword, database=testDatabase)
		cursor = db.cursor()
        try:
            cursor.execute("begin")
			
            #为一个账户Bob的余额减1
            query = "update t_user_balance set balance = balance - 1  where user='Bob' and balance>1)
            affected = cursor.execute(query)
			if affected == 0: #余额不足，回滚事务
				cursor.execute("rollback")
				return 
				
            #为一个账户John的余额加1
            query = "update t_user_balance set balance = balance + 1  where user='John')
            cursor.execute(query)
			
            # 为了安全起见，建议在这里执行‘select gtid()’获取当前事务的id值，便于后续跟踪事务的执行情况
			
			#提交事务
            cursor.execute("commit")
            except pymysql.err.MySQLError as e:
			# 发生故障，回滚事务
            cursor.execute("rollback")
```
### 2.7 自增字段
创建 sequence：
DCDB 创建 sequence 和 MySQL 自增字段的语法一样，示例如下：
```
	mysql> create table auto_inc (a int,b int,c int auto_increment,d int,key auto(c),primary key p(a,d)) shardkey=d;
	Query OK, 0 rows affected (0.12 sec)
```

插入 sequence：
DCDB 插入 sequence 和 MySQL 自增字段一样，用户可以不传该字段的值，或者传 0，NULL，这时 DCDB 自动分配一个全局唯一的值，示例如下：
```
	mysql> insert into shard.auto_inc ( a,b,d,c) values(1,2,3,0),(1,2,4,0);
	Query OK, 2 rows affected (0.05 sec)
	Records: 2  Duplicates: 0  Warnings: 0
	
	mysql> select last_insert_id();
	+------------------+
	| last_insert_id() |
	+------------------+
	| 1                |
	+------------------+
	1 row in set (0.00 sec)
	
	mysql> select * from shard.auto_inc;
	+---+------+---+---+
	| a | b    | c | d |
	+---+------+---+---+
	| 1 |    2 | 2 | 4 |
	| 1 |    2 | 1 | 3 |
	+---+------+---+---+
	2 rows in set (0.03 sec)

	mysql> insert into shard.auto_inc ( a,b,d,c) values(2,2,3,NULL),(2,2,4,NULL);
	mysql> insert into shard.auto_inc ( a,b,d) values(3,2,3),(3,2,4);

	mysql> select * from shard.auto_inc;
	+---+------+---+---+
	| a | b    | c | d |
	+---+------+---+---+
	| 1 |    2 | 2 | 4 |
	| 2 |    2 | 4 | 4 |
	| 3 |    2 | 6 | 4 |
	| 1 |    2 | 1 | 3 |
	| 2 |    2 | 3 | 3 |
	| 3 |    2 | 5 | 3 |
	+---+------+---+---+
	6 rows in set (0.03 sec)
```	
    
更改当前 sequence 值，示例如下：
```
	alter table auto auto_increment=100
```
注意事项：
分布式数据库因其架构特殊性，在 proxy 正常调度切换、异常重启等过程中，sequence 无法保证连续性（但全局唯一），示例如下：
```
    mysql> insert into shard.auto_inc ( a,b,d,c) values(11,12,13,0),(21,22,23,0);
    Query OK, 2 rows affected (0.03 sec)

	mysql> select * from shard.auto_inc;
	+----+------+------+----+
	| a  | b    | c    | d  |
	+----+------+------+----+
	| 21 |   22 | 2002 | 23 |
	|  1 |    2 |    2 |  4 |
	|  2 |    2 |    4 |  4 |
	|  3 |    2 |    6 |  4 |
	|  1 |    2 |    1 |  3 |
	|  2 |    2 |    3 |  3 |
	|  3 |    2 |    5 |  3 |
	| 11 |   12 | 2001 | 13 |
	+----+------+------+----+
	8 rows in set (0.03 sec)

	mysql> select last_insert_id();
	+------------------+
	| last_insert_id() |
	+------------------+
	| 2001             |
	+------------------+
```

### 2.8 SQL命令限制

DCDB 目前支持的 sql 命令如下：
1. delele,update,insert,replace,select
2. alter,create,drop,truncate
3. show,describe(desc,explain),help
4. start,begin,commit,rollback,savepoint
5. set

> **注意：**
> 对于一般的查询数据库状态信息的 sql，proxy 会发往默认 shard，这样查询统计信息的话，看到的结果是单个 shard 的信息。

### 2.9 用户权限相关限制

暂不支持使用 sql 命令通过 proxy 进行用户权限相关的设置，请至【腾讯云管理中心】>【云数据库】>【DCDB】>【管理】进行操作。

### 2.10 聚合函数限制
1. 如果需要`distinct`后再做聚合，那么 where 条件必须带 shardkey。
```
select count(distinct a)，sum(distinct a)，avg(distinct a) from table where sk=\*\*
```
2. 对于`distinct`、`order by`、`group by`若后面跟函数，该函数必须出现在`select`的字段中，而且必须定义别名，对应`distinct`、`order by`、`group by`后使用别名。
```
select concat(...) as substr from table where ... order by substr
```
3. `group by`的字段必须在`select`的字段中，如下`select`中必须包含字段b。
```
select count(a),b from test group by b
```