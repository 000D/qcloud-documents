## 适用场景

当需要复制一个超过 5 GB 的对象时，您需要选择分块复制的方法来实现。使用分块上传的 API 来创建一个新的对象，并使用 Part Copy 的功能，携带 `x-cos-copy-source` 头部来指定源对象，流程包括：

1. 初始化一个分块上传的对象
2. 复制源对象的数据，可指定 `x-cos-copy-range` 头部，每次只可复制最多 5 GB 数据
3. 完成分块上传

使用腾讯云 COS 提供的 SDK 可以轻松完成分块复制的功能。

## 使用方法

### 使用 C++ SDK

对象存储 COS 的 C++ SDK 中提供了方法，可参考 C++ SDK 接口文档中的以下部分：

- Initiate Multipart Upload

#### 步骤说明

1. 传入配置文件路径初始化 CosConfig，初始化 CosAPI 对象。
2. 调用 InitMultiUpload() 来初始化分块上传，获取上传 Id。
3. 反复调用 UploadPartCopyData() 方法来复制一个分块，其中 UploadPartCopyDataReq 需要提供存储桶名称、对象键名称、上传 Id、分块号， 并使用 UploadPartCopyDataReq::SetXCosCopySource 设置待拷贝的源文件。
4. 执行 CompleteMultiUpload() 方法来完成一个分块上传，需要提供存储桶名、对象键名称、UploadId 以及所有分块信息。

#### 代码示例

下列的代码示例演示了如何分块复制对象：

```cpp
qcloud_cos::CosConfig config("./config.json");
qcloud_cos::CosAPI cos(config);

std::string bucket_name = "cpp_sdk_v5-12345";
std::string object_name = "sevenyou";
std::string upload_id = ""; 
std::vector<std::string> etags;
std::vector<int64_t> part_nums;

// 1. 调用InitMultiUpload获取uploadId
qcloud_cos::InitMultiUploadReq req(bucket_name, object_name);
qcloud_cos::InitMultiUploadResp resp;
qcloud_cos::CosResult init_result = cos.InitMultiUpload(init_req, init_resp);

if (init_result.IsSucc()) {
    upload_id = init_resp.GetUploadId();
} else {
    // do sth
}

// 2.1 拷贝第一个分片
{
    std::string part_number = 1; 
    qcloud_cos::UploadPartCopyDataReq req(bucket_name, object_name, upload_id, part_number);
    req.SetXCosCopySource("sevenyousouthtest-12345656.cn-south.myqcloud.com/sevenyou_source_obj");
    qcloud_cos::UploadPartCopyDataResp resp;
    qcloud_cos::CosResult result = cos.UploadPartCopyData(req, &resp);
    if (result.IsSucc()) {
        etags.push_back(resp.GetEtag());
        part_nums.push_back(part_number);
    }
}

// 2.2 拷贝第二个分片
{
    std::string part_number = 2; 
    qcloud_cos::UploadPartCopyDataReq req(bucket_name, object_name, upload_id, part_number);
    req.SetXCosCopySource("sevenyousouthtest-12345656.cn-south.myqcloud.com/sevenyou_source_obj");
    qcloud_cos::UploadPartCopyDataResp resp;
    qcloud_cos::CosResult result = cos.UploadPartCopyData(req, &resp);
    if (result.IsSucc()) {
        etags.push_back(resp.GetEtag());
        part_nums.push_back(part_number);
    }
}

// 2.x 拷贝后续分片
...

// 3. 调用CompleteMultiUpload结束分片拷贝
qcloud_cos::CompleteMultiUploadReq comp_req(bucket_name, object_name, upload_id);
qcloud_cos::CompleteMultiUploadResp comp_resp;
comp_req.SetEtags(etags);
comp_req.SetPartNumbers(part_numbers);

qcloud_cos::CosResult comp_result = cos.CompleteMultiUpload(comp_req, &comp_resp);
```

可以通过 copy() 方法来复制一个对象，自动根据拷贝源对象的大小和所处地域来调用不同的接口，只需要提供存储桶名、对象键名称以及拷贝源存储桶、源对象键、源地域：

```cpp
qcloud_cos::CosConfig config("./config.json");
qcloud_cos::CosAPI cos(config);

std::string bucket_name = "cpp_sdk_v5-12345";
std::string object_name = "sevenyou";

qcloud_cos::CopyReq req(bucket_name, object_name);
qcloud_cos::CopyResp resp;

req.SetXCosCopySource("sevenyou-54321.cos.ap-beijing.myqcloud.com/sevenyou_copy_test");
qcloud_cos::CosResult result = cos.Copy(req, &resp);
```
### 使用 Java SDK

对象存储 COS 的 Java SDK 中提供了此方法，可参考 Java SDK 接口文档 

#### 步骤说明



#### 代码示例



### 使用 JavaScript SDK

对象存储 COS 的 JavaScript SDK 中提供了此方法，可参考 JavaScript SDK 接口文档 

#### 步骤说明



#### 代码示例



### 使用 Node.js

对象存储 COS 的 Node.js SDK 中提供了此方法，可参考 Node.js SDK 接口文档 

#### 步骤说明



#### 代码示例



### 使用 PHP SDK

对象存储 COS 的 PHP SDK 中提供了此方法，可参考 PHP SDK 接口文档 

#### 步骤说明



#### 代码示例



### 使用 Python SDK

对象存储 COS 的 Python SDK 中提供了此方法，可参考 Python SDK 接口文档 

#### 步骤说明



#### 代码示例

