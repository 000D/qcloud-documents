## 5.1 Functions
This section describes the IM solution between VJs and viewers, which is mainly used to achieve the following functions:
(1) Ordinary text messages
(2) Bullet screen messages
(3) Like messages
(4) System notices, for example "XXX has joined the studio" or "The VJ has left".
![](//mc.qcloudimg.com/static/img/d77b0df57a0aa4b102d13868bbdc4cd4/image.png)

"**Tencent Cloud IM**" (https://www.qcloud.com/product/im.html) service provides a complete set of systematic IM solutions. This section will introduce how to use Tencent Cloud IM service to implement the aforementioned functions.

## 5.2 Activating the IM Service
Before using Tencent Cloud IM service, you need first activate the service in the following steps:

Go to "IM console" (https://console.qcloud.com/avc). If you do not have the service, just click the **Directly activate IM** button. For a Tencent Cloud account, the IM App list is empty, as shown below:
![](//mc.qcloudimg.com/static/img/c033ddba671a514c7b160e1c99a08b55/image.png)

Click the **Create App access** button to create a new App access, that is, the name of the App that you want to access Tencent Cloud IM service. Our test App is called "small LVB demo", as shown below:
![](//mc.qcloudimg.com/static/img/897bff65af6202322a434b6fa3f8a0bd/image.png)

Click the OK button, then you can see in the App list the item you just added, as shown below:
![](//mc.qcloudimg.com/static/img/1c1cb2c2fa4c6f0dc7be06bf8329dee3/image.png)

As shown above, the SDKAPPID column shows the ID of Tencent Cloud IM service, which is used in interworking the IM SDKs for various platform versions. An **Application configuration** button is on the right side. Click the button to enter the next configuration step, as shown below.
![](//mc.qcloudimg.com/static/img/d52ac3662d5310673a5d6c6a78f50da4/image.png)


Many configuration items are available here, most of which are not important. You may not configure them or just modify them as needed at any time. For example,
-**Account name**: You can fill in any name. Do not use very strange characters.

-**Verification method**: Currently only the "system generated public key" is supported, so you can skip this configuration item.

-**Account administrator name**: A user ID for debugging purpose. If you are an engineer, directly fill in your commonly used account ID. It is only used for the advanced features of the IM service.

-**Verification SMS signature**: Prefix of text messages. Fill in the App's Chinese name.

-**Integration mode**: Hosted mode is recommended.

Details about the integration mode will be described in 5.3. Here you just need to click the **Save** button.

## 5.3 Integration Mode
"Integration mode" concerns the identities (accounts) of IM senders and recipients. Taking into account the needs of a wide range of clients, Tencent Cloud provides two solutions: **guest (hosted) mode** and **independent (verification) mode**.

| Integration mode | Applicable scenario | Interworking difficulty | Design goal |
|------------|-------------|-------------| -----------|
| Guest (hosted) mode | Suitable for scenarios with rather low **identity verification requirements**, such as the LVB chat room scenario that allows all App users to join.  | Log in to the IM SDK using the guestLogin mode, and the interworking cost is extremely low.  | The design goal is to reduce interworking cost, so that you can use the IM services without interworking with the account system. Tencent Cloud will generate for each App user a <font color = "blue>"Guest Account"</font> , The account will only be used to send and receive messages. |
| Independent (authentication) mode | Suitable for clients with high **identity verification requirements**. For example, only registered users of your App can send and receive messages.  | The UserSig security signature is required and interworking cost is relatively high. | The design goal is to assign the permission for sending and receiving messages to the client. It needs your login server to confirm the legitimate identity of App user and then allocate signatures. Tencent Cloud checks the authenticity of signatures before allowing them to send and receive messages. This guarantees that all message senders and receivers are accounts in your account system. |

### 5.3.1 Guest (Hosted) Mode
The design goal of the guest mode is to reduce interworking cost, so that you can use the IM services without interworking with the account system. Tencent Cloud will generate for each App user a <font color = "blue>"Guest Account"</font> , The account will only be used to send and receive messages. You can reckon these guests accounts as "puppet accounts". The sender's real user information (nickname, avatar, etc.) is not bound to the guest account, but is sent along with the message body.

Its access process is very simple: clicking mouse + writing a few lines of interworking codes.

(1) First, select **hosted mode** for the integration mode in **5.2**, so that Tencent Cloud can provide backend support for guest accounts in the guest mode.
(2) In the client codes, interwork with the guest login mode of IM SDK, which includes function calls in TLS (Tencent Login Service, a core component of Tencent IM SDK) and IM SDK.

If you already have small LVB source codes, you only need to call a function (for the iOS platform: the guestLogin function in TCIMPlatform.h; for the Android platform: the guestLogin function in TCLoginMgr.java). Relevant logics have been encapsulated in the function. The source codes are explained below:

-**iOS platform**
   + Query SDKAPPID. For how to obtain the ID, see Section **5.2** of the reference.
   + Call the TLSGuestLogin function in the TLSHelper header file, which will request a guest account from the backend of Tencent Cloud. If the SDKAPPID in the first step is correct and your mobile phone can access the Internet, you will get a TLSUserInfo object. TLSUserInfo.identifier is the ID of this guest account.
   + Call the getTLSUserSig function in TLSHelper to generate a valid UserSig signature for this identifier.
   + Finally, you can construct a TIMLoginParam object with the aforementioned identifier and UserSig. Then call the login function in TIMManager to complete the IM SDK login process.
 
```objective-c
// Code example 1:  Call the guest login mode of TLS 
- (void)guestLogin:(UIButton *)button {
    TLSUserInfo *info = [[TLSHelper getInstance] getGuestIdentifier];
    int ret = [[TLSHelper getInstance] TLSGuestLogin:self];
    if (ret == 0) {
           // During login, a turning chrysanthemum appears
    } else {
           // TLSHelper error, please check whether IMSDK_APPID is wrong
    }
}

// Code example 2:  Call the IM SDK login after successful TLS login 
- (void)OnGuestLoginSuccess:(TLSUserInfo *)userInfo {
    TIMLoginParam *loginParam = [[TIMLoginParam alloc] init];
    loginParam.appidAt3rd = @"88888888"; // Enter your SDKAPPID
    LoginParam.sdkAppId = 88888888 // Fill in your SDKAPPID
    loginParam.accountType = @"0";
    loginParam.identifier = userInfo.identifier;
    loginParam.userSig = [[TLSHelper getInstance] getTLSUserSig:userInfo.identifier];

    [[TIMManager sharedInstance] login:loginParam succ:^{
		     / / OK. Login succeeded and then you can send messages!
    } fail:^(int code, NSString *msg) {
        // IM SDK login failed. Please check whether the IMSDK_APPID is correct
    }];
}
```


-**Android platform**
   + Query SDKAPPID. For how to obtain the ID, see Section **5.2** of the reference.
   + Call the TLSGuestLogin function of TLS to complete guest login. It will request a guest account from the backend of Tencent Cloud. If the SDKAPPID in the first step is correct and your mobile phone can access the Internet, you will get a TLSUserInfo object. TLSUserInfo.identifier is the ID of this guest account.
   + Call the getUserSig function of TLS to generate a valid UserSig signature for this identifier.
   + Finally, you can call the login function in TIMManager with the aforementioned identifier and UserSig to complete the IM SDK login process.

```java
// Code example:  Implement IM SDK guest login on the Android platform
public void guestLogin() {
   / / Call the guest login mode of TLS 
   mTLSLoginHelper.TLSGuestLogin(new TLSGuestLoginListener() {
       @Override
       public void OnGuestLoginSuccess(TLSUserInfo tlsUserInfo) {
           // Set SDKAPPID
           TIMUser user = new TIMUser();
           user.setAccountType(String.valueOf(TCConstants.IMSDK_ACCOUNT_TYPE));
           user.setAppIdAt3rd(String.valueOf(TCConstants.IMSDK_APPID));
           user.setIdentifier(tlsUserInfo.identifier);
           String userSig = mTLSLoginHelper.getUserSig(identifier);

            // Initiate the IM SDK login operation. You can send messages after successful login 
            TIMManager.getInstance().login(TCConstants.IMSDK_APPID, user, userSig, new TIMCallBack() {
                @Override
                public void onSuccess() {
                    / / OK. Login succeeded and then you can send messages!
                }
							  @Override
                public void onError(int i, String s) {
                   // IM SDK login failed. Please check whether the IMSDK_APPID is correct
                }
            });
        }
    });
}
```

### 5.3.2 Independent (Authentication) Mode

The design goal of the independent mode is to assign the permission for sending and receiving messages to the client. It needs your login server to confirm the legitimate identity of App user and then allocate signatures. Tencent Cloud checks the authenticity of signatures before allowing them to send and receive messages. This guarantees that all message senders and receivers are accounts in your account system.

This mode is suitable for clients with high **identity verification requirements**. For example, only registered users of your App can send and receive messages. <font color = 'red'>If you do not have very urgent such demand, this mode is not recommended.</font> </font>

The interworking steps are as follows:
> 1. On the Tencent Cloud IM "Console" (https://console.qcloud.com/avc), set the integration mode to **independent mode**, and download the public and private keys used in the signature.
> ![](//mc.qcloudimg.com/static/img/4e79ff175d8053f8998e02732468e398/image.png)
> 
> 2. The mobile App login logic still uses your original process, that is, sending ID + PASSWORD to your login server for verification. After a successful login, your login server needs to issue to the App an additional UserSig signature, which is used together with the ID corresponding to the private key downloaded in Step 1 to carry out "Asymmetric encryption" (https://www.qcloud.com/Doc /product /269/1510).
> 3. After obtaining the ID and UserSig, the mobile App can call the IM SDK's imLogin (ID, UserSig) API to perform login. Tencent Cloud backend will use the public key downloaded in Step 1 to accomplish decryption and therefore to verify whether the ID is accepted by your login server.

The above steps are shown in the following sketch:
![](//mc.qcloudimg.com/static/img/1e541b2931d0cb8fb1815f26aa8fb493/image.png)

This seems a bit complicated. Its underlying principle is about **how two companies' backend servers trust each other**. The following is a more vivid example: 
> 1. A female user logs in to your App with the ID and password she has registered here before. Her ID is "Huaxianzi."
>> 2. You carry out verification immediately after getting her ID and password, and confirm that she can log in to the App. You also issue to her a **pass (UserSig)**, which says "<font color = 'blue'> 'Huaxianzi' is good guy. You should treat her right when she goes to your place...</font> ". In order to ensure that the pass will not be forged, you also affix your signature.
>> 3. After reading your pass, Tencent Cloud confirms that the signature is real and will provide appropriate services.

This is the message verification behind the interworking program. Its core goal is to prevent those users not accepted by your backend server from sending and receiving messages. However it is inappropriate to let your server check each message, so this solution is developed.

## 5.4 Messaging
Tencent Cloud IM service supports a variety of message formats, such as text, picture, emoji, voice or even small files, which you can learn at "IM document zone" (https://www.qcloud.com/doc/product/269 ).

Comparatively, LVB messages are rather simple, mainly including the following types:
- Ordinary text messages: including sender nicknames and message bodies.
- Bullet screen messages: They are also text messages in nature, but with more fancy display modes.
- Like messages: When a viewer sends a like to a VJ, you need to ensure that other viewers can see it.
- System notices, for example "XXX has joined the studio" or "The VJ has left".

For this relatively simple scenario, we use a very simple method in small LVB: **Text message channel is used uniformly to send and receive messages. For the demand for assembling multiple fields (for example message type, user avatar, nickname), we use the json format for data assembly.**

For example: "Huaxianzi" sends to the VJ a message of "Guy, shown me a smile". Using the above method, the real text message is sent as follows:
```json
{
    "userAction": 1,
	"userId": 27149, 
	"nickName": "Huaxianzi", 
	"headPic": "http: //www.test.com/headpic/27149.png",
	"msg": "Guy, shown me a smile"
}
```
**userAction** is the message type we define in small LVB. It have five options:

| userAction | Number | Meaning |
|---------|---------|---------|
| AVIMCMD_Custom_Text | 1 | Text message |
| AVIMCMD_Custom_EnterLive | 2 | A user joins LVB |
| AVIMCMD_Custom_ExitLive | 3 | A user exits LVB |
| AVIMCMD_Custom_Like | 4 | Like message |
| AVIMCMD_Custom_Danmaku | 5 | Bullet screen message |

The following are source codes for small LVB, which, for your reference, are used to send an ordinary text message:

### 5.4.1 iOS Platform
```
//The source codes are in the TCChatRoomMgr.java file
- (void)sendMessage:(AVIMCommand)cmd userId:(NSString *)userId
             nickName:(NSString *)nickName 
						 headPic:(NSString *)headPic 
						 msg:(NSString *)msgContent
{
    if ((AVIMCMD_Custom_Text == cmd || AVIMCMD_Custom_Danmaku == cmd) && msgContent.length == 0)
    {
        DebugLog(@"sendMessage failed, msg length is 0");
        return;
    }
    
    NSDictionary* dict = @{@"userAction" : @(cmd),
		@"userId" : TC_PROTECT_STR(userId), 
		@"nickName" : TC_PROTECT_STR(nickName), 
		@"headPic" : TC_PROTECT_STR(headPic), 
		@"msg" : TC_PROTECT_STR(msgContent)};
    
    NSData* data = [TCUtil dictionary2JsonData:dict];
    NSString *content = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];

    TIMTextElem *textElem = [[TIMTextElem alloc] init];
    [textElem setText:content];

    TIMMessage *timMsg = [[TIMMessage alloc] init];
    [timMsg addElem:textElem];

    [_chatRoomConversation sendMessage:timMsg succ:^{
        DebugLog(@"sendMessage success, cmd:%d", cmd);
    } fail:^(int code, NSString *msg) {
        DebugLog(@"sendMessage failed, cmd:%d, code:%d, errmsg:%@", cmd, code, msg);
    }];
}
```

### 5.4.2 Android Platform
```
//The source codes are in the TCChatRoomMgr.java file
private void sendMessage(int cmd, String param, TIMValueCallBack<TIMMessage> timValueCallBack) 
{
    JSONObject sendJson = new JSONObject();
    try {
		sendJson.put("userAction", cmd);
        sendJson.put("userId", TCUserInfoMgr.getInstance().getUserId());
        sendJson.put("nickName", TCUserInfoMgr.getInstance().getNickname());
        sendJson.put("headPic", TCUserInfoMgr.getInstance().getHeadPic());
        sendJson.put("msg", param);
    } catch (JSONException e) {
        e.printStackTrace();
    }
    
	String cmds = sendJson.toString();
    TIMMessage msg = new TIMMessage();
    TIMTextElem elem = new TIMTextElem();
    elem.setText(cmds);
		
	if (msg.addElement(elem) != 0) {
	    Log.d(TAG, "addElement failed");
        return;
	}
	sendTIMMessage(msg, timValueCallBack);
}
```


